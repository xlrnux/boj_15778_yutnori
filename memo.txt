??? Stick: 윷 4개
Horse mine: 내 말 4개
Horse your: 상대편 말 4개

개요
네 개의 [말]을
 [처음의 위치(=날밭)]에서 "시작" 해서
[윷판]을 "돌아서"
다시 [처음의 위치(=날밭)]으로 "돌아온"
이후에 "탈출"하는 게임

말 {
int state;
  0: 시작하지않음
  1: 시작
  int point; // 좌표
}

윷가락 {
1. 앞뒷면이 있다
F = 앞 = 1
B = 뒤 = 0
if
  네개의 윷 모두가 뒷면이면 "5칸을 전진"
  -> 네개의 합이 0 이면 "5칸을 전진"
else
  네개의 윷 중 앞면의 개수 == 전진하는 칸수
  -> 네개의 합만큼 전진

정리





}

vector<char> Map[31];

움직임 {
규칙은 배열로 만들었음.
    char name;
    scanf(" %c", &name);
    int move = 0;
    for(int i = 0; i < 4; i++){
        char input;
        scanf(" %c", &input);
        if(input - 'B') move++;
    }

    int nextPos = PATTERN[ horse[name] ][ MOVE[move] ];
    if(!Map[nextPos].empty()
    && 도착지점에 적군이 있다? // 아래 정리
    && 단, nextPos != 30 ){ // 도착지점은 잡기 안하는걸로

    }

    if(내가 지금있는 지점에 아군이 있다?){ // 아래 정리
    }


    MOVE[move];

}


if(도착지점에 적군이 있다?){
/*
잡는 규칙!!
누가 먼저 도착해 있었냐가 포인트.
   1. 도착지점을 계산해냄.
   2. 해당 벡터를 비우면서
      각 말의 시작으로 돌려버림. horse[가는말].set(가는말);
   3. 그러고 나서 이동 시작.
   */
}

if(내가 지금있는 지점에 아군이 있다?){
/*
업는 규칙!!
도착지점은 상관할 바가 아니다.(알아서 될 것이다)
맵을 vector 로 만들어서 같은 좌표에 있는건 싹다 똑같이
움직이도록 처리.
!!주의할것은 같이 움직이는 말들의 좌표도 갱신해주어야 함
*/
}

